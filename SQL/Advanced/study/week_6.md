# 정규 표현식(Regular Expressions)

## 정규표현식이란?
복잡한 검색 조건을 패턴으로 표현할 수 있는 문자열 매칭 도구

## 정규 표현식 문법
정규표현식은 일정한 패턴을 가진 문자열 집합을 표현하기 위한 문법이다.

가장 단순한 정규표현식: 특수문자가 없는 일반 문자열

- 예시: `hello`라는 정규표현식은 'hello'와 정확히 일치하는 문자열만 매칭

특수기호와 구조를 사용해서 다양한 문자열을 매칭할 수 있다.

- 예시: `hello|world`는 "hello" 또는 "world" 중 하나를 매칭

| 기호      | 의미 및 설명                                                                  |                                  |                     |
| ------- | ------------------------------------------------------------------------ | -------------------------------- | ------------------- |
| ^    | 문자열의 **시작**을 의미합니다. <br> 예:<br>`^fo`는 `"fo"`로 시작하는 문자열에 매칭됨              |                                  |                     |
| $     | 문자열의 **끝**을 의미합니다. <br> 예:<br>`o$`는 `"o"`로 끝나는 문자열에 매칭됨                  |                                  |                     |
| .     | **임의의 문자 1개**를 의미합니다. <br> 기본은 줄바꿈 포함 안 함. `'m'` 옵션이나 `(?m)`을 써야 줄바꿈 포함  |                                  |                     |
| *     | 바로 앞 문자가 **0번 이상 반복**되는 패턴입니다. <br> 예: `'a*'`은 "", "a", "aa", "aaa", ... |                                  |                     |
| +     | 바로 앞 문자가 **1번 이상 반복**되는 패턴입니다. <br> 예: `'a+'`는 "a", "aa", "aaa", ...     |                                  |                     |
| ?     | 바로 앞 문자가 **0번 또는 1번 등장**합니다. <br> 예: `'a?'`는 "", "a"에만 매칭                |                                  |                     |
| \`      | \`                                                                       | **OR (또는)** 조건입니다. <br> 예: \`'pi | apa'\`는 둘 중 하나에 매칭됨 |
| ()    | 그룹 지정. 패턴 반복 시 함께 적용됨 <br> 예: `^(pi)*$`는 "pi", "pipi", "" 등을 매칭          |                                  |                     |
| {n}   | 앞 항목이 **정확히 n번 반복** <br> `{m,n}`: **m\~n번 반복** <br> `{n,}`: **n번 이상 반복** |                                  |                     |
| []    | 문자 집합. **괄호 안 <u>문자 중 하나</u>와 매칭** <br> `[^]`는 부정 (괄호 안 제외한 문자와 매칭)             |                                  |                     |
| [=x=] | **동등 클래스(equivalence class)** — 같은 정렬 값을 갖는 모든 문자 매칭                     |                                  |                     |


## 정규 표현식 문법 예제별 설명

### ^: 문자열 시작 매칭
```MYSQL
SELECT REGEXP_LIKE('fofo', '^fo');        -- 결과: 1 (fo로 시작)
SELECT REGEXP_LIKE('fo\nfo', '^fo$');     -- 결과: 0 (∵줄바꿈이 있음)  
```
🌱 `^fo$`를 처음 봤을 때는 f로 시작하고 o로 끝나면 된다고 생각했는데, 그게 아니라 표현식이 fo와 정확히 일치해야한다는 뜻이었음

🌱fo로 시작해서 fo로 끝나는 표현식을 쓰고싶다면, `^fo.*fo$`라고 써야함. 완전히 다름!!

### $: 문자열 끝 매칭
```mysql
SELECT REGEXP_LIKE('fo\no', '^fo\no$');   -- 결과: 1
SELECT REGEXP_LIKE('fo\no', '^fo$');      -- 결과: 0
```
✅ 두번째 경우에는 fo와 완벽히 일치해야 1의 결과를 얻을 수 있음

### .: 임의문자(m옵션)
```mysql
SELECT REGEXP_LIKE('fo\r\nfo', '^f.*$');     -- 결과: 0 (줄바꿈 미포함)
SELECT REGEXP_LIKE('fo\r\nfo', '^f.*$', 'm'); -- 결과: 1 (줄바꿈 포함)
```
`.(dot)`
- 임의의 문자 한 개를 의미
- 줄바꿈 문자(\n, \r)는 포함하지 않음
- 줄바꿈도 매치시키려면 옵션 'n'을 사용하거나, 특수문법 ?s 를 사용해야함

`'m' multi-line 옵션`
- ^: 표현현의 시작 → 각 줄의 시작
- $: 표현의 끝 → 각 표현의 끝

**기본 정규식 예시**
```mysql
SELECT REGEXP_LIKE('fo\r\nfo', '^f.*$');  -- 결과: 0
```
fo\r\nfo는 줄바꿈이 포함된 문자열로
```markdown
fo
fo
```
과 같음

#### 🔎왜 매칭되지 않을까?
`^f.*$`는 
전체 문자열이:
- f로 시작하고
- 임의의 문자가 줄바꿈 없이 0개 이상 있고(*)
- 마지막이 문자열의 끝인 경우만 
1로 반환

🌱 하지만 여기엔 줄바꿈이 중간에 있기 때문에 `.*`가 줄바꿈을 건너뛰지 못하고 멈춰버림 ⇒ 0 반환

**멀티옵션을 사용한다면?**
```mysql
SELECT REGEXP_LIKE('fo\r\nfo', '^f.*$', 'm');  -- 결과: 1
```
#### 🔎왜 매칭될까?
'm' 옵션은 ^와 $를 "문자열의 전체가 아닌, 각 줄의 시작과 끝" 으로 해석

- 첫 줄 fo에 대해 `^f.*$` 적용 → ✅
- 두 번째 줄 fo도 마찬가지 → ✅

🌱 그래서 전체 문자열 중 하나의 줄이라도 만족하면 1 반환


### *: 0회 이상 반복
```mysql
SELECT REGEXP_LIKE('Bn', '^Ba*n');        -- 결과: 1 ("a" 0번)
SELECT REGEXP_LIKE('Baaan', '^Ba*n');     -- 결과: 1 ("a" 여러 번)
```

### +: 1회 이상 반복
```mysql
SELECT REGEXP_LIKE('Ban', '^Ba+n');       -- 결과: 1
SELECT REGEXP_LIKE('Bn', '^Ba+n');        -- 결과: 0
```
✅ 두번째 경우는 a가 1회이상 반복되어야하기 때문에 a가 존재하지 않은 Bn과는 매칭되지 않음

### ?: 0~1회 등장
```mysql
SELECT REGEXP_LIKE('Ban', '^Ba?n');       -- 결과: 1
SELECT REGEXP_LIKE('Baan', '^Ba?n');      -- 결과: 0
```
✅ 두번째 경우는 a가 2번 반복되기 때문에 a가 아예 반복되지 않거나 1번 반복되는 경우와는 매칭되지 않음

### | : 또는, 혹은, OR
```MYSQL
SELECT REGEXP_LIKE('pi', 'pi|apa');         -- 결과: 1
SELECT REGEXP_LIKE('apa', '^(pi|apa)$');    -- 결과: 1
SELECT REGEXP_LIKE('pix', '^(pi|apa)$');    -- 결과: 0
```
✅ 세번째 경우는 pi나 apa와 정확히 일치하는 경우만 매칭된다.

### (abc)* : 그룹 반복
```MYSQL
SELECT REGEXP_LIKE('pipi', '^(pi)*$');    -- 결과: 1
SELECT REGEXP_LIKE('pip', '^(pi)*$');     -- 결과: 0
```
✅ 두번째 경우와 매칭되려면 `^(pip)*$`가 되어야 함

### {n}, {m,n}: 반복 수 지정
```
SELECT REGEXP_LIKE('abcde', 'a[bcd]{2}e');       -- 결과: 0
SELECT REGEXP_LIKE('abcde', 'a[bcd]{3}e');       -- 결과: 1
SELECT REGEXP_LIKE('abcde', 'a[bcd]{1,10}e');    -- 결과: 1
```
`a[bcd]{2}e`
- 문자열 a로 시작해야하고
- [bcd]{2}: b,c,d 중 하나가 정확히 2번 나와야 하고,
- 문자열 e로 끝나야함.

✅ 첫번째 예시가 0으로 반환되는 이유는 b,c,d 중 하나가 2번 나와야하는데, bcd 3개가 나와서 패턴에 일치하는 표현식이 아니게 됨.

✅ 세번째 예시의 {1,10}은 최소 1~ 최대 10번 반복이라는 뜻임


### [], [^]: 문자 집합 및 범위
```mysql
SELECT REGEXP_LIKE('aXbc', '[a-dXYZ]');          -- 결과: 1 (X 포함)
SELECT REGEXP_LIKE('gheis', '^[^a-dXYZ]+$');     -- 결과: 1 (배제 문자만 포함)
SELECT REGEXP_LIKE('gheisa', '^[^a-dXYZ]+$');    -- 결과: 0 (마지막에 'a' 포함)
```

#### []: 문자 집합
- [abc]는 문자 a,b,c 중 하나라도 일치하면 매칭
- [a-z]는 a부터 z까지 모든 **소문자** 알파벳 중 하나에 매칭

**예시: [a-dXYZ]**
다음 중 하나라도 포함되면 매칭
- a,b,c,d
- X,Y,Z 

#### [^]: 부정 문자 집합
- [^abc] : a,b,c를 제외한 모든 문자와 매칭
- ^가 맨 앞에 있는 경우만 부정으로 해석함. 
    -[a^b]는 부정이 아님

## 정규표현식 함수 요약

| 이름                 | 설명                                     |
| ------------------ | -------------------------------------- |
| NOT REGEXP       | REGEXP의 부정(조건이 *매치되지 않을* 때 참)        |
| REGEXP           | 문자열이 정규표현식과 일치하는지 여부 판단                |
| REGEXP_INSTR()   | 정규표현식에 일치하는 **서브문자열의 시작 위치 반환**        |
| REGEXP_LIKE()    | 문자열이 정규표현식과 일치하는지 여부 판단 (REGEXP와 동일) |
| RLIKE            | REGEXP와 동의어(같은 기능)                   |

## 정규표현식 함수 설명 및 에제

### expr REGEXP pat / expr RLIKE pat

expr(문자열)이 pat(패턴)에 일치하면 1, 아니면 0, NULL이면 NULL

```MYSQL
SELECT 'Michaell' REGEXP '.*';
SELECT 'a' REGEXP '^[a-d]';
SELECT 'abc' REGEXP 'ABC';
```

**결과**

1 <-- 임의의 문자 1개가 0회 이상 반복 → ✅

1 <-- a~d사이의 값으로 시작함 → ✅

1 <-- 기본 옵션은 대소문자 구분 안함 → ✅


### NOT REGEXT pat, expr NOT RLIKE pat

`NOT (expr REGEXT pat)`과 동일한 의미
```mysql
SELECT 'apple' NOT REGEXP '^a';
```
**결과**

0 <-- a로 시작함 → ❌

### REGEXP_LIKE(expr, pat[,match_type])
REGEXP와 완전히 동일하지만, match_type 옵션으로 매칭 방식을 세밀하게 제어

#### 옵션(match_type)
- c: 대소문자 구분
- i: 대소문자 무시
- m: 멀티옵션(^, $가 줄마다 인식)
- n: .이 줄바꿈 문자까지 포함

```mysql
SELECT REGEXP_LIKE('abc', 'ABC');          -- 결과: 1 (기본은 대소문자 무시)
SELECT REGEXP_LIKE('abc', 'ABC', 'c');     -- 결과: 0 (대소문자 구분 시)
```

### REGEXP_INSTR(expr, pat[,pos[,occurence[, return_option[, match_type]]]])

pat과 일치하는 <u>expr의 **서브문자열 시작위치**</U> 반환

- pos: 검색 시작 위치(기본값:1)
- occurence: 몇 번째 일치 항목을 찾을지(기본값:1)
- return_option:
    - 0: 매치된 위치 반환
    - 1: 매치된 그 뒤의 반환
- match_type: 위의 옵션과 동일

```
SELECT REGEXP_INSTR('dog cat dog', 'dog');        -- 결과: 1 (첫 번째 'dog')
SELECT REGEXP_INSTR('dog cat dog', 'dog', 2);     -- 결과: 9 (두 번째 'dog')
SELECT REGEXP_INSTR('aa aaa aaaa', 'a{4}');        -- 결과: 8 (4연속 'a')
```
✅띄어쓰기도 포함된다!

### REGEXP_REPLACE(expr, pat, repl[, pos,[, occurence[, match_type]]])
expr내에서 pat과 일치하는 부분을 repl로 치환

```mysql
SELECT REGEXP_REPLACE('a b c', 'b', 'X'); -- 결과: 'a X c'
SELECT REGEXP_REPLACE('abc def ghi', '[a-z]+', 'X', 1, 3); -- 결과: 'abc def X'
```

- 'abc def ghi': 대상 문자열 (expr)
- '[a-z]+':	정규표현식 패턴 - 알파벳 소문자 1개 이상으로 이루어진 문자열
- 'X'	치환할 문자열
- 1: 검색 시작 위치 (1부터 시작)
- 3: 세 번째 일치 항목만 치환

-----

# 비트 연산자
## 비트 연산자 및 함수 목록 요약
| 연산자/함수        | 설명              |          |
| ------------- | --------------- | -------- |
| `&`           | 비트 AND 연산       |          |
| \`            | \`              | 비트 OR 연산 |
| `^`           | 비트 XOR 연산       |          |
| `~`           | 비트 반전 (NOT)     |          |
| `<<`          | 비트 왼쪽 쉬프트       |          |
| `>>`          | 비트 오른쪽 쉬프트      |          |
| `BIT_COUNT()` | 설정된 1 비트의 개수 반환 |          |

## 비트연산자의 숫자모드와 이진 문자열 모드

### 1. 숫자 연산 모드
- 숫자끼리 계산
- 모든 숫자는 내부적으로 64비트 정수로 바꾼 후의 연산이 진행됨
    
    ➡️ 결과가 숫자로 나옴

```MYSQL
SELECT 29 | 15; 

### 계산 과정
29 = 11101
15 = 01111
OR  = 11111 → 31

### 결과
31
```

### 2. 이진 문자열 모드
- BINARY,VARBINARY,BLOB 타입의 데이터끼리 연산하면
    
    ➡️결과가 문자열로 나옴

```MYSQL
SELECT HEX(_binary 'A' | 'B');  

### 연산 과정
A = 0x41 = 01000001
B = 0x42 = 01000010
OR 연산 → 01000011 = 0x43 = 'C'

### 결과
C
```

**⚠️ 이진 문자열은 길이가 달라도 에러가 난다**
```MYSQL
SELECT _binary 'AB' | _binary 'C';  
-- ❌ 오류! (길이 다름: 2 vs 1)
```
✅ 비트 연산은 짝을 맞춰 비교하는 것이 필요한데, 길이가 다르면 비교할 수 없기 때문에 에러 발생

## 비트 연산자 상세 설명(숫자형만)
### | : 비트OR
각 자리의 비트가 둘 중 하나라도 1이면 1

```MYSQL
SELECT 29 | 15;     

### 연산과정   
29: 11101, 
15: 01111 
----------
    11111

### 결과: 
31
```
### &: 비트 AND
양쪽 비트가 모두 1일 때만 1

```MYSQL
SELECT 29 & 15;

### 연산과정
  11101
& 01111 
---------
= 01101 

###결과 
→ 13
```

### ^ : 비트 XOR
비트가 서로 다르면 1, 같으면 0

```MYSQL
SELECT 1 ^ 1;  -- 0
SELECT 1 ^ 0;  -- 1
```
```MYSQL
SELECT 11 ^ 3; 

### 연산과정
    1011 
^   0011 
---------
=   1000 

### 결과
8
```

### ~ : 비트 반전
모든 비트를 반대로 (1→0, 0→1)

```MYSQL
SELECT 5 & ~1

###연산과정
5:  0101, 
~1: 1110(원래는 0001)

    0101 
&   1110 
----------
=   0100 

###결과

4
```


### << : 왼쪽 쉬프트
비트를 왼쪽으로 밀고, 남은 오른쪽은 0으로 채움
- 쉬프트 하면 값이 2의 N제곱 배가 됨

```MYSQL
SELECT 1 << 2
```
✅1을 왼쪽으로 2칸 민다는 뜻
    ➡️ 1→100  결과:4


### >> : 오른쪽 쉬프트
비트를 오른쪽으로 밀고, 남은 왼쪽은 0으로 채움

```MYSQL
SELECT 4 >> 2;
```
✅ 4를 오른쪽으로 2칸 
    ➡️ 100 → 1 결과: 1


### BIT_COUNT(N)
N안에 있는 1의 개수 반환
- 인자는 숫자 또는 바이너리 문자열 가능

```MYSQL
SELECT BIT_COUNT(64);   

###연산 방법
64 = 1000000 

### 결과: 1개
```
